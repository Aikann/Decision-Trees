import cplexfrom cplex.exceptions import CplexErrorimport sysimport csvimport mathimport getoptimport regtrees as trfrom learn_tree_funcs import *DEPTH_VAR = 1PURELEAF_VAR = 2LEAFDEPTH_VAR = 3SCORE_VAR = 4LEAFERROR_VAR = 5ctype = SCORE_VARcontinuousconstant = 0# create the ILP variables, add to VARS dictionarydef create_variables(depth):    global VARS    var_value = 0    var_names = []    var_types = ""    var_lb = []    var_ub = []    var_obj = []        num_features = get_num_features()    data_size = get_data_size()        num_leafs = 2**depth    num_nodes = num_leafs-1    # node n had a boolean test on feature f, boolean    for n in range(num_nodes):        for f in range(num_features):            VARS["node_feature_" + str(n) + "_" + str(f)] = var_value            var_names.append("#" + str(var_value))            var_types = var_types + "B"            var_lb.append(0)            var_ub.append(1)            var_obj.append(0)            var_value = var_value + 1    # value used in the boolean test in node n, integer    for n in range(num_nodes):        VARS["node_constant_" + str(n)] = var_value        var_names.append("#" + str(var_value))        if continuousconstant == 1:            var_types = var_types + "C"        else:            var_types = var_types + "I"        var_lb.append(get_min_value())        var_ub.append(get_max_value())        var_obj.append(0)        var_value = var_value + 1    # leaf l predicts type s, boolean    for s in range(get_num_targets()):        for l in range(num_leafs):            VARS["prediction_type_" + str(s) + "_" + str(l)] = var_value            var_names.append("#" + str(var_value))            var_types = var_types + "B"            var_lb.append(0)            var_ub.append(1)            var_obj.append(0)            var_value = var_value + 1    if ctype == DEPTH_VAR or ctype == LEAFDEPTH_VAR or ctype == SCORE_VAR or ctype == LEAFERROR_VAR:        for l in range(depth):            for d in range(data_size):                VARS["depth_true_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "B"                var_lb.append(0)                var_ub.append(1)                var_obj.append(0)                var_value = var_value + 1    if ctype == DEPTH_VAR or ctype == LEAFDEPTH_VAR or ctype == PURELEAF_VAR:        for d in range(data_size):            VARS["row_error_" + str(d)] = var_value            var_names.append("#" + str(var_value))            var_types = var_types + "C"            var_lb.append(0)            var_ub.append(1)            var_obj.append(1)            var_value = var_value + 1    # positive error, continuous    if ctype == LEAFDEPTH_VAR or ctype == LEAFERROR_VAR:        for d in range(data_size):            for l in range(num_leafs):                VARS["leaf_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(1)                var_obj.append(0)                var_value = var_value + 1    if ctype == PURELEAF_VAR:        for d in range(data_size):            for l in range(num_leafs):                VARS["leaf_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "B"                var_lb.append(0)                var_ub.append(1)                var_obj.append(0)                var_value = var_value + 1    # positive error, continuous    if ctype == SCORE_VAR:        for d in range(data_size):            for l in range(num_leafs):                VARS["score_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(get_max_error())                var_obj.append(-1)                var_value = var_value + 1        for d in range(data_size):            VARS["scoreC_" + str(d)] = var_value            var_names.append("#" + str(var_value))            var_types = var_types + "C"            var_lb.append(1)            var_ub.append(1)            var_obj.append(1)            var_value = var_value + 1    if ctype == LEAFERROR_VAR:        for s in range(get_num_targets()):            for l in range(num_leafs):                VARS["error_leaf_" + str(s) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(max([sum([1 for d in range(data_size) if get_target(d) != TARGETS[s2]]) for s2 in range(get_num_targets())]))                var_obj.append(1)                var_value = var_value + 1    return var_names, var_types, var_lb, var_ub, var_obj# add rows for valid depth assignmentsdef create_constant_depth_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size):        for n in range(num_nodes):            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])                        col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [- get_feature_value(d,f) for f in range(num_features)]            max_check = get_max_value() - min_val            max_check = max([get_max_value_f(f) - get_feature_value(d,f) for f in range(num_features)])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)                        num_false = 0                        for l in range(1,path_len):                node = path[l*2]                dir = path[l*2+1]                                if dir == "left":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - 1 - l)]])                    col_values.extend([max_check])                if dir == "right":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - 1 - l)]])                    col_values.extend([-max_check])                    num_false = num_false + 1                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len-1)]])            col_values.extend([-max_check])            col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check*(path_len-num_false-1) - MIN_DIST)            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size):        for n in range(num_nodes):            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [get_feature_value(d,f) for f in range(num_features)]            max_check = max_val - get_min_value()            max_check = max([get_feature_value(d,f) - get_min_value_f(f) for f in range(num_features)])                        path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)                        num_false = 0                        for l in range(1,path_len):                node = path[l*2]                dir = path[l*2+1]                                if dir == "left":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - l - 1)]])                    col_values.extend([max_check])                if dir == "right":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - l - 1)]])                    col_values.extend([-max_check])                    num_false = num_false + 1            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len-1)]])            col_values.extend([max_check])            col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([-1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check * (path_len-num_false))            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_constant_leaf_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size):        col_names = [VARS["leaf_" + str(d) + "_" + str(l)] for l in range(num_leafs)]        col_values = [1 for l in range(num_leafs)]        row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1    for d in range(data_size):        for n in range(num_nodes):            lower_leafs = get_right_leafs(n, num_nodes)            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])                        col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            #col_values = [max_val - get_feature_value(d,f) + 0.5*MIN_DIST for f in range(num_features)]            #col_values = [max_val - get_feature_value(d,f) for f in range(num_features)]            col_values = [- get_feature_value(d,f) for f in range(num_features)]            max_check = get_max_value() - min_val            max_check = max([get_max_value_f(f) - get_feature_value(d,f) for f in range(num_features)])                        col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([max_check for l in lower_leafs])                        col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([1])            #col_names.extend([VARS["node_active_" + str(n)]])            #col_values.extend([-2*get_max_value()])            #row_names.append("node_ub_" + str(d) + "_" + str(n))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check)            #row_right_sides.append(max_val)            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size):        for n in range(num_nodes):            lower_leafs = get_left_leafs(n, num_nodes)            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            #col_values = [get_feature_value(d,f) - min_val + 0.5*MIN_DIST for f in range(num_features)]            #col_values = [get_feature_value(d,f) - min_val for f in range(num_features)]            col_values = [get_feature_value(d,f) for f in range(num_features)]            max_check = max_val - get_min_value()            max_check = max([get_feature_value(d,f) - get_min_value_f(f) for f in range(num_features)])            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([max_check for l in lower_leafs])            col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([-1])            #col_names.extend([VARS["node_active_" + str(n)]])            #col_values.extend([-2*get_max_value()])                        #row_names.append("node_lb_" + str(d) + "_" + str(n))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check - MIN_DIST)            #row_right_sides.append(max_val)            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_score_depth_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_right_leafs(n, num_nodes))                    col_names = []            col_values = []            col_names.extend([VARS["score_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1 for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([-1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_left_leafs(n, num_nodes))            col_names = []            col_values = []            col_names.extend([VARS["score_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1 for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(1)            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_leaf_depth_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size):        col_names = [VARS["leaf_" + str(d) + "_" + str(l)] for l in range(num_leafs)]        col_values = [1 for l in range(num_leafs)]        row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1    for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_left_leafs(n, num_nodes))                    col_names = []            col_values = []            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1 for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([-1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "E"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_value    for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_right_leafs(n, num_nodes))            col_names = []            col_values = []            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1 for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(1)            row_senses = row_senses + "E"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_depth_error_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        print TARGETS, get_num_targets()        for d in range(data_size):        for l in range(num_leafs):            path = get_path(l, num_nodes)            path_len = int(len(path)/2.0)            col_names = []            col_values = []            num_false = 0                        for i in range(path_len):                node = path[i*2]                dir = path[i*2+1]                                if dir == "left":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - i - 1)] ])                    col_values.extend([1])                if dir == "right":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - i - 1)] ])                    col_values.extend([-1])                    num_false = num_false + 1            col_names.extend([VARS["row_error_" + str(d)]])            col_values.extend([-1])            for s in range(get_num_targets()):                if TARGETS[s] != get_target(d):                    col_names.extend([VARS["prediction_type_" + str(s) + "_" + str(l)]])                    col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(path_len-num_false)            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_score_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for d in range(data_size):        for l in range(num_leafs):            col_names = []            col_values = []                        for s in range(get_num_targets()):                if TARGETS[s] == get_target(d):                    col_names.extend([VARS["prediction_type_" + str(s) + "_" + str(l)]])                    col_values.extend([-1])            col_names.extend([VARS["score_" + str(d) + "_" + str(l)]])            col_values.extend([1])            #row_names.append("error_" + str(d) + "_" + str(l))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1        return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_leaf_error_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for d in range(data_size):        for l in range(num_leafs):            col_names = [VARS["leaf_" + str(d) + "_" + str(l)]]            col_values = [1]                        for s in range(get_num_targets()):                if TARGETS[s] == get_target(d):                    col_names.extend([VARS["prediction_type_" + str(s) + "_" + str(l)]])                    col_values.extend([-1])            col_names.extend([VARS["row_error_" + str(d)]])            col_values.extend([-1])            #row_names.append("error_" + str(d) + "_" + str(l))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1        return row_names, row_values, row_right_sides, row_senses, row_valuedef create_leaf_error_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for s in range(get_num_targets()):        for l in range(num_leafs):            col_names = [VARS["error_leaf_" + str(s) + "_" + str(l)]]            col_values = [-1]                        max_val = max([sum([1 for d in range(data_size) if get_target(d) != TARGETS[s2]]) for s2 in range(get_num_targets())])            col_names.extend([VARS["prediction_type_" + str(s) + "_" + str(l)]])            col_values.extend([max_val])                        col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for d in range(data_size) if get_target(d) != TARGETS[s]])            col_values.extend([1 for d in range(data_size) if get_target(d) != TARGETS[s]])                        #row_names.append("error_" + str(d) + "_" + str(l))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_val)            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_rows(depth):    global VARS    row_value = 0    row_names = []    row_values = []    row_right_sides = []    row_senses = ""    num_features = get_num_features()    data_size = get_data_size()    num_leafs = 2**depth    num_nodes = num_leafs-1        for n in range(num_nodes):        col_names = [VARS["node_feature_" + str(n) + "_" + str(f)] for f in range(num_features)]        col_values = [1 for f in range(num_features)]        row_names.append("#"+str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1        for l in range(num_leafs):        col_names = [VARS["prediction_type_" + str(s) + "_" + str(l)] for s in range(get_num_targets())]        col_values = [1 for s in range(get_num_targets())]        row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1        if ctype == DEPTH_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value            nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_depth_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == PURELEAF_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_leaf_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_leaf_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == LEAFDEPTH_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_leaf_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_leaf_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == SCORE_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value              nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_score_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_score_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value                          if ctype == LEAFERROR_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_leaf_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_leaf_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if inputsym == 1:        for n in range(num_nodes):            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [- get_max_value_f(f) for f in range(num_features)]                    col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([1])                    row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1            for n in range(num_nodes):            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [get_min_value_f(f) for f in range(num_features)]                    col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([-1])                    row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1        for n in range(num_nodes):            left_leaf = get_left_leafs(n, num_nodes)            right_leaf = get_right_leafs(n, num_nodes)            if len(left_leaf) != 1:                continue                    for s in range(get_num_targets()):                col_names = [VARS["prediction_type_" + str(s) + "_" + str(left_leaf[0])]]                col_values = [1]                    col_names.extend([VARS["prediction_type_" + str(s) + "_" + str(right_leaf[0])]])                col_values.extend([1])                    row_names.append("#" + str(row_value))                row_values.append([col_names,col_values])                row_right_sides.append(1)                row_senses = row_senses + "L"                row_value = row_value + 1        if double_data == True:            if ctype != PURELEAF_VAR:                for dp in range(depth):                    col_names = []                    col_values = []                                        col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp)] for d in range(data_size)])                    col_values.extend([1 for d in range(data_size)])                    row_names.append("#" + str(row_value))                    row_values.append([col_names,col_values])                    row_right_sides.append(0.5 * data_size)                    row_senses = row_senses + "L"                    row_value = row_value + 1            else:                for n in range(num_nodes):                    lower_leafs = get_left_leafs(n, num_nodes)                    col_names = []                    col_values = []                                        for l in lower_leafs:                        col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for d in range(data_size)])                        col_values.extend([1 for d in range(data_size)])                    row_names.append("#" + str(row_value))                    row_values.append([col_names,col_values])                    row_right_sides.append(0.5 * data_size)                    row_senses = row_senses + "L"                    row_value = row_value + 1    return row_names, row_values, row_right_sides, row_sensesdef print_nodes(node, diff, depth, solution_values, num_nodes, num_features):    if diff > 0:        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), "<=", solution_values[VARS["node_constant_" + str(node)]]        print_nodes(node-diff, diff/2, depth+1, solution_values, num_nodes, num_features)        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), ">", solution_values[VARS["node_constant_" + str(node)]]        print_nodes(node+diff, diff/2, depth+1, solution_values, num_nodes, num_features)    else:        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), "<=", solution_values[VARS["node_constant_" + str(node)]]        for l in get_left_leafs(node, num_nodes):            for s in range(get_num_targets()):                if solution_values[VARS["prediction_type_" + str(s) + "_" + str(l)]] > 0.5:                    print "  " * (depth+1), l, TARGETS[s]        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), ">", solution_values[VARS["node_constant_" + str(node)]]        for l in get_right_leafs(node, num_nodes):            for s in range(get_num_targets()):                if solution_values[VARS["prediction_type_" + str(s) + "_" + str(l)]] > 0.5:                    print "  " * (depth+1), l, TARGETS[s]def print_tree(num_nodes, solution_values, num_features):    print "tree:"    diff = (num_nodes + 1) / 2    print_nodes(diff-1, diff / 2, 0, solution_values, num_nodes, num_features)    print "discrimination difference", solution_values[VARS["discrimination_diff_1"]] + solution_values[VARS["discrimination_diff_2"]]def get_start_solutions(depth):    global inputsym    col_var_names = []    col_var_values = []    num_features = get_num_features()    num_leafs = 2**depth    num_nodes = num_leafs-1        num_features = get_num_features()    data_size = get_data_size()        num_leafs = 2**depth    num_nodes = num_leafs-1        values = tr.dt.tree_.value        for n in range(num_nodes):        feat = sget_feature(tr.dt, convert_node(tr.dt, n, num_nodes))                if feat < 0:            feat = 0        for f in range(num_features):            if f == feat:                col_var_names.extend([VARS["node_feature_" + str(n) + "_" + str(f)]])                col_var_values.extend([1])            else:                col_var_names.extend([VARS["node_feature_" + str(n) + "_" + str(f)]])                col_var_values.extend([0])                val = sget_node_constant(tr.dt, convert_node(tr.dt, n, num_nodes))                if inputsym == 1 and len(get_left_leafs(n, num_nodes)) == 1:            ll = get_left_leafs(n, num_nodes)[0]            rl = get_right_leafs(n, num_nodes)[0]                        predl = values[convert_leaf(tr.dt, ll, num_nodes)].tolist()[0]            predr = values[convert_leaf(tr.dt, rl, num_nodes)].tolist()[0]                        if predl.index(max(predl)) == predr.index(max(predr)):                val = get_max_value_f(feat)                col_var_names.extend([VARS["node_constant_" + str(n)]])        col_var_values.extend([int(math.floor(val))])    odd = False    prev_max_class = -1        for l in reversed(range(num_leafs)):        predictions = values[convert_leaf(tr.dt, l, num_nodes)].tolist()[0]        max_index = predictions.index(max(predictions))        max_class = tr.dt.classes_[max_index]                if inputsym == 1 and odd and max_class == prev_max_class:            if TARGETS[0] == max_class:                col_var_names.extend([VARS["prediction_type_" + str(0) + "_" + str(num_leafs - 1 - l)]])                col_var_values.extend([0])                col_var_names.extend([VARS["prediction_type_" + str(1) + "_" + str(num_leafs - 1 - l)]])                col_var_values.extend([1])            else:                col_var_names.extend([VARS["prediction_type_" + str(0) + "_" + str(num_leafs - 1 - l)]])                col_var_values.extend([1])                col_var_names.extend([VARS["prediction_type_" + str(1) + "_" + str(num_leafs - 1 - l)]])                col_var_values.extend([0])            for s in range(2,get_num_targets()):                col_var_names.extend([VARS["prediction_type_" + str(s) + "_" + str(num_leafs - 1 - l)]])                col_var_values.extend([0])        else:            for s in range(get_num_targets()):                if TARGETS[s] == max_class:                    col_var_names.extend([VARS["prediction_type_" + str(s) + "_" + str(num_leafs - 1 - l)]])                    col_var_values.extend([1])                else:                    col_var_names.extend([VARS["prediction_type_" + str(s) + "_" + str(num_leafs - 1 - l)]])                    col_var_values.extend([0])                prev_max_class = max_class        odd = not odd        return col_var_names, col_var_valuesdef lpdtree(depth):    global SORTED_FEATURE, inputstart, inputtime, inputpolish    prob = cplex.Cplex()    num_features = get_num_features()    data_size = get_data_size()    num_leafs = 2**depth    num_nodes = num_leafs-1    try:        prob.objective.set_sense(prob.objective.sense.minimize)        var_names, var_types, var_lb, var_ub, var_obj = create_variables(depth)        print "num_vars", len(var_names)        prob.variables.add(obj = var_obj, lb = var_lb, ub = var_ub, types = var_types)#, names = var_names)        row_names, row_values, row_right_sides, row_senses = create_rows(depth)        print "num_rows", len(row_names)        prob.linear_constraints.add(lin_expr = row_values, senses = row_senses, rhs = row_right_sides, names = row_names)                col_names = []        order_set = []        for n in range(num_nodes):            for f in range(num_features):                order_set.append((VARS["node_feature_" + str(n) + "_" + str(f)], 11+2*((num_nodes - get_num_parents(n,num_nodes))), 1))        for n in range(num_nodes):            order_set.append((VARS["node_constant_" + str(n)], 10+2*((num_nodes - get_num_parents(n,num_nodes))), -1))        if ctype == DEPTH_VAR or ctype == LEAFDEPTH_VAR or ctype == SCORE_VAR or ctype == LEAFERROR_VAR:            for l in range(depth):                for d in range(data_size):                    order_set.append((VARS["depth_true_" + str(d) + "_" + str(l)], 1 +(depth - l), -1))               prob.order.set(order_set)        if inputstart == 1:            col_var_names, col_var_values = get_start_solutions(depth)            prob.MIP_starts.add([col_var_names, col_var_values], prob.MIP_starts.effort_level.auto)            prob.write("test.lp")        prob.parameters.emphasis.mip.set(1)        #prob.parameters.advance.set(2)        #prob.parameters.mip.strategy.branch.set(1)        #prob.parameters.mip.strategy.backtrack.set(1.0)        #prob.parameters.mip.strategy.nodeselect.set(2)        prob.parameters.mip.strategy.variableselect.set(-1)        #prob.parameters.mip.strategy.bbinterval.set(0)        #prob.parameters.mip.strategy.rinsheur.set(50)        #prob.parameters.mip.strategy.lbheur.set(1)        #prob.parameters.mip.strategy.probe.set(3)        #prob.parameters.preprocessing.presolve.set(1)        prob.parameters.mip.polishafter.time.set(inputtime - inputpolish)        prob.parameters.timelimit.set(inputtime)                        prob.solve()    except CplexError, exc:        print exc        return []        print    print "Solution status = " , prob.solution.get_status(), ":", prob.solution.status[prob.solution.get_status()]    if "infeasible" in prob.solution.status[prob.solution.get_status()]:        return []        print "Solution value  = ", prob.solution.get_objective_value()        num_features = get_num_features()    data_size = get_data_size()        num_leafs = 2**depth    num_nodes = num_leafs-1    solution = []    solution_values = prob.solution.get_values()        print_tree(num_nodes, solution_values, num_features)    return solution    for n in range(num_nodes):        for f in range(num_features):            SORTED_FEATURE = f            all_rows = sorted(range(data_size), key=get_sorted_feature_value)            if solution_values[VARS["node_feature_" + str(n) + "_" + str(f)]] == 1.0:                print solution_values[VARS["node_constant_" + str(n)]]                print [get_feature_value(d,f) for d in all_rows if sum([int(solution_values[VARS["score_" + str(d) + "_" + str(l)]]) for l in get_left_leafs(n, num_nodes)]) > 0]                print [get_feature_value(d,f) for d in all_rows if sum([int(solution_values[VARS["score_" + str(d) + "_" + str(l)]]) for l in get_right_leafs(n, num_nodes)]) > 0]    for d in range(data_size):        print get_target(d), \              [int(round(100.0 * get_target(d) * solution_values[VARS["row_error_" + str(d)]]))] , \              [[int(round(100.0 * solution_values[VARS["prediction_type_" + str(s) + "_" + str(l)]])) for s in range(get_num_targets())] for l in range(num_leafs)], \              [int(round(100.0 * (solution_values[VARS["score_" + str(d) + "_" + str(l)]]))) for l in range(num_leafs)]    return solutiondef run():    read_file('winequality-red.csv')    #read_file('iris.csv')    transform_data()    write_file('winequality-red-transformed.csv')    tr.df = tr.get_wine_data()    tr.learnTrees(3)    tr.get_code()    lpdtree(3)def main(argv):   global inputstart   global inputsym   global inputtime   global inputpolish   global double_data   global ctype   global continuousconstant   inputfile = ''   outputfile = ''   try:      opts, args = getopt.getopt(argv,"f:d:s:y:t:p:u:v:c:",["ifile=","depth=","start=","symmetry=","timelimit=","polishtime=","doubledata=","variant=","constant="])   except getopt.GetoptError:      sys.exit(2)   for opt, arg in opts:      if opt in ("-f", "--ifile"):         inputfile = arg      elif opt in ("-d", "--depth"):         inputdepth = int(arg)      elif opt in ("-s", "--start"):         inputstart = int(arg)      elif opt in ("-y", "--symmetry"):         inputsym = int(arg)      elif opt in ("-u", "--doubledata"):         if int(arg) == 1:            double_data = True         else:            double_data = False      elif opt in ("-t", "--timelimit"):         inputtime = int(arg)      elif opt in ("-p", "--polishtime"):         inputpolish = int(arg)      elif opt in ("-v", "--variant"):         ctype = int(arg)      elif opt in ("-c", "--constant"):         continuousconstant = int(arg)   read_file(inputfile)   #read_file('iris.csv')   transform_data()   write_file(inputfile+".transformed")   tr.df = tr.get_data(inputfile+".transformed")   tr.learnTrees(inputdepth)   tr.get_code()   lpdtree(inputdepth)if __name__ == "__main__":   main(sys.argv[1:])