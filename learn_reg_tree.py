import cplexfrom cplex.exceptions import CplexErrorimport sysimport csvimport mathimport getoptimport regtrees as trfrom learn_tree_funcs import *DEPTH_VAR = 1PURELEAF_VAR = 2LEAFDEPTH_VAR = 3SCORE_VAR = 4MINMAX_VAR = 5UPDOWNDERR_VAR = 6ctype = SCORE_VARcontinuousconstant = 0# encode range in binarydef create_binary_encoding_rec(olist):    if len(olist) == 1:        return [[0]]    mid_point = int(len(olist)/2.0)    indexes = [1 for i in range(mid_point)]    indexes.extend([0 for i in range(mid_point, len(olist))])    remain1 = create_binary_encoding_rec(olist[:mid_point])    remain2 = create_binary_encoding_rec(olist[mid_point:])    result = []    result.extend([indexes[:len(olist)]])    for i in range(len(remain1)):        remain = remain1[i]        remain.extend(remain2[i])        result.extend([remain[:len(olist)]])    return resultdef create_binary_encoding(olist):    result = create_binary_encoding_rec(olist)    if all( v is 0 for v in result[-1] ):        return result[:-1]    return resultdef test_binary_encoding():    print create_binary_encoding(range(4))    print create_binary_encoding(range(5))    res = create_binary_encoding(range(10))    for i in range(len(res[0])):        print [res[v][i] for v in range(len(res))]    res = create_binary_encoding(range(15))    for i in range(len(res[0])):        print [res[v][i] for v in range(len(res))]# create the ILP variables, add to VARS dictionarydef create_variables(depth):    global VARS    var_value = 0    var_names = []    var_types = ""    var_lb = []    var_ub = []    var_obj = []        num_features = get_num_features()    data_size = get_data_size()        num_leafs = 2**depth    num_nodes = num_leafs-1    # node n has a boolean test on feature f, boolean    for n in range(num_nodes):        for f in range(num_features):            VARS["node_feature_" + str(n) + "_" + str(f)] = var_value            var_names.append("#" + str(var_value))            var_types = var_types + "B"            var_lb.append(0)            var_ub.append(1)            var_obj.append(0)            var_value = var_value + 1    # value used in the boolean test in node n, continuous    for n in range(num_nodes):        VARS["node_constant_" + str(n)] = var_value        var_names.append("#" + str(var_value))        if continuousconstant == 1:            var_types = var_types + "C"        else:            var_types = var_types + "I"        var_lb.append(get_min_value())        var_ub.append(get_max_value())        var_obj.append(0)        var_value = var_value + 1    # prediction for leaf l, continuous    for l in range(num_leafs):        VARS["prediction_" + str(l)] = var_value        var_names.append("#" + str(var_value))        var_types = var_types + "C"        var_lb.append(get_min_target())        var_ub.append(get_max_target())        var_obj.append(0)        var_value = var_value + 1    if ctype == DEPTH_VAR or ctype == LEAFDEPTH_VAR or ctype == SCORE_VAR or ctype == UPDOWNDERR_VAR:        for l in range(depth):            for d in range(data_size):                VARS["depth_true_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "B"                var_lb.append(0)                var_ub.append(1)                var_obj.append(0)                var_value = var_value + 1    if ctype == DEPTH_VAR or ctype == LEAFDEPTH_VAR or ctype == PURELEAF_VAR or ctype == MINMAX_VAR:        for d in range(data_size):            VARS["error_row_" + str(d)] = var_value            var_names.append("#" + str(var_value))            var_types = var_types + "C"            var_lb.append(0)            var_ub.append(get_max_error())            var_obj.append(1)            var_value = var_value + 1    # positive error, continuous    if ctype == LEAFDEPTH_VAR or ctype == UPDOWNDERR_VAR:        for d in range(data_size):            for l in range(num_leafs):                VARS["leaf_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(1)                var_obj.append(0)                var_value = var_value + 1    if ctype == PURELEAF_VAR or ctype == MINMAX_VAR:        for d in range(data_size):            for l in range(num_leafs):                VARS["leaf_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "B"                var_lb.append(0)                var_ub.append(1)                var_obj.append(0)                var_value = var_value + 1    # positive error, continuous    if ctype == SCORE_VAR:        for d in range(data_size):            for l in range(num_leafs):                VARS["score_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(get_max_error())                var_obj.append(-1)                var_value = var_value + 1        for d in range(data_size):            VARS["scoreC_" + str(d) + "_" + str(l)] = var_value            var_names.append("#" + str(var_value))            var_types = var_types + "C"            var_lb.append(get_max_error())            var_ub.append(get_max_error())            var_obj.append(1)            var_value = var_value + 1    # minimum value for featre f in node n (another way to specify constants), continuous    if ctype == MINMAX_VAR:        for n in range(num_nodes):            for f in range(num_features):                VARS["node_constant_min_" + str(n) + "_" + str(f)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(get_min_value_f(f))                var_ub.append(get_max_value_f(f))                var_obj.append(0)                var_value = var_value + 1        # maximum value for featre f in node n (another way to specify constants), continuous        for n in range(num_nodes):            for f in range(num_features):                VARS["node_constant_max_" + str(n) + "_" + str(f)] = var_value                #var_names.append("node_constant_" + str(n))                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(get_min_value_f(f))                var_ub.append(get_max_value_f(f))                var_obj.append(0)                var_value = var_value + 1    if ctype == UPDOWNDERR_VAR:        for d in range(data_size):            for l in range(num_leafs):                VARS["error1_" + str(d) + "_" + str(l)] = var_value                #var_names.append("error_" + str(d))                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(get_max_error())                var_obj.append(0.5)                var_value = var_value + 1        for d in range(data_size):            for l in range(num_leafs):                VARS["error2_" + str(d) + "_" + str(l)] = var_value                #var_names.append("error_" + str(d))                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(get_max_error())                var_obj.append(0.5)                var_value = var_value + 1        for d in range(data_size):            for l in range(num_leafs):                VARS["error3_" + str(d) + "_" + str(l)] = var_value                #var_names.append("error_" + str(d))                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(get_max_error())                var_obj.append(0.5)                var_value = var_value + 1        for d in range(data_size):            for l in range(num_leafs):                VARS["error4_" + str(d) + "_" + str(l)] = var_value                #var_names.append("error_" + str(d))                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0)                var_ub.append(get_max_error())                var_obj.append(0.5)                var_value = var_value + 1                    for d in range(data_size):            for l in range(num_leafs-1):                VARS["scoreC_" + str(d) + "_" + str(l)] = var_value                var_names.append("#" + str(var_value))                var_types = var_types + "C"                var_lb.append(0.5*get_max_error())                var_ub.append(0.5*get_max_error())                var_obj.append(-1)                var_value = var_value + 1        return var_names,var_types, var_lb, var_ub, var_objdef create_leaf_depth_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size):        col_names = [VARS["leaf_" + str(d) + "_" + str(l)] for l in range(num_leafs)]        col_values = [1 for l in range(num_leafs)]        row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1    for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_left_leafs(n, num_nodes))                    col_names = []            col_values = []            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1 for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([-1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "E"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_value    for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_right_leafs(n, num_nodes))            col_names = []            col_values = []            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1 for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(1)            row_senses = row_senses + "E"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_score_depth_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_left_leafs(n, num_nodes))                    col_names = []            col_values = []            col_names.extend([VARS["score_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1.0/float(get_max_error()) for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([-1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1    #return row_names, row_values, row_right_sides, row_senses, row_value    for d in range(data_size):        for dp in range(1,depth+1):            lower_leafs = []            for n in range(num_nodes):                if get_depth(n, num_nodes) == dp:                    lower_leafs.extend(get_right_leafs(n, num_nodes))            col_names = []            col_values = []            col_names.extend([VARS["score_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([1.0/float(get_max_error()) for l in lower_leafs])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp-1)]])            col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(1)            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_constant_leaf_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size):        col_names = [VARS["leaf_" + str(d) + "_" + str(l)] for l in range(num_leafs)]        col_values = [1 for l in range(num_leafs)]        row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1    for d in range(data_size):        for n in range(num_nodes):            lower_leafs = get_right_leafs(n, num_nodes)            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])                        col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            #col_values = [max_val - get_feature_value(d,f) + 0.5*MIN_DIST for f in range(num_features)]            #col_values = [max_val - get_feature_value(d,f) for f in range(num_features)]            col_values = [- get_feature_value(d,f) for f in range(num_features)]            max_check = get_max_value() - min_val            max_check = max([get_max_value_f(f) - get_feature_value(d,f) for f in range(num_features)])                        col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([max_check for l in lower_leafs])                        col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([1])            #col_names.extend([VARS["node_active_" + str(n)]])            #col_values.extend([-2*get_max_value()])            #row_names.append("node_ub_" + str(d) + "_" + str(n))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check)            #row_right_sides.append(max_val)            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size):        for n in range(num_nodes):            lower_leafs = get_left_leafs(n, num_nodes)            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            #col_values = [get_feature_value(d,f) - min_val + 0.5*MIN_DIST for f in range(num_features)]            #col_values = [get_feature_value(d,f) - min_val for f in range(num_features)]            col_values = [get_feature_value(d,f) for f in range(num_features)]            max_check = max_val - get_min_value()            max_check = max([get_feature_value(d,f) - get_min_value_f(f) for f in range(num_features)])            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs])            col_values.extend([max_check for l in lower_leafs])            col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([-1])            #col_names.extend([VARS["node_active_" + str(n)]])            #col_values.extend([-2*get_max_value()])                        #row_names.append("node_lb_" + str(d) + "_" + str(n))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check - MIN_DIST)            #row_right_sides.append(max_val)            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_min_max_leaf_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()        row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for d in range(data_size):        col_names = [VARS["leaf_" + str(d) + "_" + str(l)] for l in range(num_leafs)]        col_values = [1 for l in range(num_leafs)]        row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1        for d in range(data_size):        for n in range(num_nodes):            for f in range(num_features):                lower_leafs = get_left_leafs(n, num_nodes)                col_names = [VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs]                col_values = [get_feature_value(d,f) - get_min_value_f(f) for l in lower_leafs]                                col_names.extend([VARS["node_constant_min_" + str(n) + "_" + str(f)]])                col_values.extend([-1])                                row_names.append("#" + str(row_value))                row_values.append([col_names,col_values])                row_right_sides.append( - get_min_value_f(f))                row_senses = row_senses + "L"                row_value = row_value + 1    for d in range(data_size):        for n in range(num_nodes):            for f in range(num_features):                lower_leafs = get_right_leafs(n, num_nodes)                col_names = [VARS["leaf_" + str(d) + "_" + str(l)] for l in lower_leafs]                col_values = [get_max_value_f(f) - get_feature_value(d,f) for l in lower_leafs]                                col_names.extend([VARS["node_constant_max_" + str(n) + "_" + str(f)]])                col_values.extend([1])                                row_names.append("#" + str(row_value))                row_values.append([col_names,col_values])                row_right_sides.append(get_max_value_f(f))                row_senses = row_senses + "L"                row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_constant_min_max_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()        row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for n in range(num_nodes):        for f in range(num_features):            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)]]            col_values = [get_max_value_f(f) - get_min_value_f(f) + MIN_DIST]                        col_names.extend([VARS["node_constant_max_" + str(n) + "_" + str(f)]])            col_values.extend([-1])                        col_names.extend([VARS["node_constant_min_" + str(n) + "_" + str(f)]])            col_values.extend([1])                        #row_names.append("node_ub_" + str(d) + "_" + str(n))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(get_max_value_f(f) - get_min_value_f(f))            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_value    for n in range(num_nodes):        col_names = []        col_values = []                col_names.extend([VARS["node_constant_max_" + str(n) + "_" + str(f)] for f in range(num_features)])        col_values.extend([1 for f in range(num_features)])                row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(get_max_value())        row_senses = row_senses + "L"        row_value = row_value + 1    for n in range(num_nodes):        col_names = []        col_values = []                col_names.extend([VARS["node_constant_min_" + str(n) + "_" + str(f)] for f in range(num_features)])        col_values.extend([1 for f in range(num_features)])                row_names.append("#" + str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(get_max_value() * (num_features-1))        row_senses = row_senses + "G"        row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_constant_depth_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size):        for n in range(num_nodes):            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])                        col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [- get_feature_value(d,f) for f in range(num_features)]            max_check = get_max_value() - min_val            max_check = max([get_max_value_f(f) - get_feature_value(d,f) for f in range(num_features)])            path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)                        num_false = 0                        for l in range(1,path_len):                node = path[l*2]                dir = path[l*2+1]                                if dir == "left":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - 1 - l)]])                    col_values.extend([max_check])                if dir == "right":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - 1 - l)]])                    col_values.extend([-max_check])                    num_false = num_false + 1                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len-1)]])            col_values.extend([-max_check])            col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check*(path_len-num_false-1) - MIN_DIST)            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size):        for n in range(num_nodes):            max_val = max([get_feature_value(d,f) for f in range(num_features)])            min_val = min([get_feature_value(d,f) for f in range(num_features)])            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [get_feature_value(d,f) for f in range(num_features)]            max_check = max_val - get_min_value()            max_check = max([get_feature_value(d,f) - get_min_value_f(f) for f in range(num_features)])                        path = get_pathn(n, num_nodes)            path_len = int(len(path)/2.0)                        num_false = 0                        for l in range(1,path_len):                node = path[l*2]                dir = path[l*2+1]                                if dir == "left":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - l - 1)]])                    col_values.extend([max_check])                if dir == "right":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - l - 1)]])                    col_values.extend([-max_check])                    num_false = num_false + 1            col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len-1)]])            col_values.extend([max_check])            col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([-1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(max_check * (path_len-num_false))            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_depth_error_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for d in range(data_size):        for l in range(num_leafs):            path = get_path(l, num_nodes)            path_len = int(len(path)/2.0)            col_names = []            col_values = []            num_false = 0                        max_check = get_max_target() - get_target(d)            for i in range(path_len):                node = path[i*2]                dir = path[i*2+1]                                if dir == "left":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - i - 1)] ])                    col_values.extend([max_check])                if dir == "right":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - i - 1)] ])                    col_values.extend([-max_check])                    num_false = num_false + 1            col_names.extend([VARS["error_row_" + str(d)]])            col_values.extend([-1])            col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append((path_len-num_false) * max_check + get_target(d))            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size):        for l in range(num_leafs):            path = get_path(l, num_nodes)            path_len = int(len(path)/2.0)            col_names = []            col_values = []            num_false = 0            max_check = get_target(d) - get_min_target()                        for i in range(path_len):                node = path[i*2]                dir = path[i*2+1]                                if dir == "left":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - i - 1)] ])                    col_values.extend([max_check])                if dir == "right":                    col_names.extend([VARS["depth_true_" + str(d) + "_" + str(path_len - i - 1)] ])                    col_values.extend([-max_check])                    num_false = num_false + 1            col_names.extend([VARS["error_row_" + str(d)]])            col_values.extend([-1])            col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([-1])            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append((path_len-num_false) * max_check - get_target(d))            row_senses = row_senses + "L"            row_value = row_value + 1        return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_leaf_error_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size-1):        for l in range(num_leafs):            col_names = [VARS["leaf_" + str(d) + "_" + str(l)]]            col_values = [get_target(d)]                        col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([-1])                        col_names.extend([VARS["error_row_" + str(d)]])            col_values.extend([-1])                        row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size-1):        for l in range(num_leafs):            col_names = [VARS["leaf_" + str(d) + "_" + str(l)]]            col_values = [get_max_target() - get_target(d)]                        col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([1])                        col_names.extend([VARS["error_row_" + str(d)]])            col_values.extend([-1])                        row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(get_max_target())#            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_score_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1    for d in range(data_size-1):        for l in range(num_leafs):            col_names = [VARS["score_" + str(d) + "_" + str(l)]]            col_values = [1]                        col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([1])                        row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(get_max_error() + get_target(d))            row_senses = row_senses + "L"            row_value = row_value + 1    for d in range(data_size-1):        for l in range(num_leafs):            col_names = [VARS["score_" + str(d) + "_" + str(l)]]            col_values = [1]                        col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([-1])                        row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(get_max_error() - get_target(d))            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_leaf_cor_error_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for d in range(data_size):        for l in range(num_leafs):            col_names = []            col_values = []                        col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([1])            #col_names.extend([VARS["node_prediction_"  + str(n)] for n in get_path(l, num_nodes)])            #col_values.extend([-1 for n in get_path(l, num_nodes)])            col_names.extend([VARS["error1_" + str(d) + "_" + str(l)]])            col_values.extend([1])            col_names.extend([VARS["error2_" + str(d) + "_" + str(l)]])            col_values.extend([-1])            col_names.extend([VARS["error3_" + str(d) + "_" + str(l)]])            col_values.extend([1])            col_names.extend([VARS["error4_" + str(d) + "_" + str(l)]])            col_values.extend([-1])            #row_names.append("error_" + str(d) + "_" + str(l))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(get_target(d))            row_senses = row_senses + "E"            row_value = row_value + 1    for d in range(data_size):        for l in range(num_leafs):            col_names = []            col_values = []                        col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)]])            col_values.extend([get_max_error()])            #col_names.extend([VARS["node_prediction_"  + str(n)] for n in get_path(l, num_nodes)])            #col_values.extend([-1 for n in get_path(l, num_nodes)])            col_names.extend([VARS["error3_" + str(d) + "_" + str(l)]])            col_values.extend([1])            col_names.extend([VARS["error4_" + str(d) + "_" + str(l)]])            col_values.extend([1])            #row_names.append("error_" + str(d) + "_" + str(l))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(get_max_error())            row_senses = row_senses + "L"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_row_leaf_4error_rows(depth, row_value):    num_features = get_num_features()    data_size = get_data_size()    row_names = []    row_values = []    row_right_sides = []    row_senses = ""        num_leafs = 2**depth    num_nodes = num_leafs-1        for d in range(data_size):        for l in range(num_leafs):            col_names = []            col_values = []                        col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([-1])            #col_names.extend([VARS["node_prediction_"  + str(n)] for n in get_path(l, num_nodes)])            #col_values.extend([-1 for n in get_path(l, num_nodes)])            col_names.extend([VARS["error1_" + str(d) + "_" + str(l)]])            col_values.extend([1])            col_names.extend([VARS["error2_" + str(d) + "_" + str(l)]])            col_values.extend([-1])            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)]])            col_values.extend([get_target(d) - get_min_target()])            #row_names.append("error_" + str(d) + "_" + str(l))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(- get_min_target())            row_senses = row_senses + "E"            row_value = row_value + 1    for d in range(data_size):        for l in range(num_leafs):            col_names = []            col_values = []                        col_names.extend([VARS["prediction_" + str(l)]])            col_values.extend([1])            #col_names.extend([VARS["node_prediction_"  + str(n)] for n in get_path(l, num_nodes)])            #col_values.extend([-1 for n in get_path(l, num_nodes)])            col_names.extend([VARS["error3_" + str(d) + "_" + str(l)]])            col_values.extend([1])            col_names.extend([VARS["error4_" + str(d) + "_" + str(l)]])            col_values.extend([-1])            col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)]])            col_values.extend([get_max_target() - get_target(d)])            #row_names.append("error_" + str(d) + "_" + str(l))            row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(get_max_target())            row_senses = row_senses + "E"            row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses, row_valuedef create_rows(depth):    global VARS    row_value = 0    row_names = []    row_values = []    row_right_sides = []    row_senses = ""    num_features = get_num_features()    data_size = get_data_size()    num_leafs = 2**depth    num_nodes = num_leafs-1    for n in range(num_nodes):        col_names = [VARS["node_feature_" + str(n) + "_" + str(f)] for f in range(num_features)]        col_values = [1 for f in range(num_features)]        row_names.append("#"+str(row_value))        row_values.append([col_names,col_values])        row_right_sides.append(1)        row_senses = row_senses + "E"        row_value = row_value + 1        if ctype == DEPTH_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value            nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_depth_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == PURELEAF_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_leaf_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_leaf_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == LEAFDEPTH_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_leaf_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_leaf_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == SCORE_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value              nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_score_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_score_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == MINMAX_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_min_max_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_min_max_leaf_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_leaf_error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    if ctype == UPDOWNDERR_VAR:        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_constant_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_leaf_depth_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value        nrow_names, nrow_values, nrow_right_sides, nrow_senses, nrow_value = create_row_leaf_4error_rows(depth, row_value)        row_names.extend(nrow_names)        row_values.extend(nrow_values)        row_right_sides.extend(nrow_right_sides)        row_senses += nrow_senses        row_value = nrow_value    #return row_names, row_values, row_right_sides, row_senses        if inputsym == 1:        for n in range(num_nodes):            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [- get_max_value_f(f) for f in range(num_features)]                    col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([1])                    row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(0)            row_senses = row_senses + "L"            row_value = row_value + 1            for n in range(num_nodes):            col_names = [VARS["node_feature_"  + str(n) + "_" + str(f)] for f in range(num_features)]            col_values = [get_min_value_f(f) for f in range(num_features)]                    col_names.extend([VARS["node_constant_" + str(n)]])            col_values.extend([-1])                    row_names.append("#" + str(row_value))            row_values.append([col_names,col_values])            row_right_sides.append(MIN_DIST)            row_senses = row_senses + "L"            row_value = row_value + 1                if double_data == True:            if ctype != PURELEAF_VAR and ctype != MINMAX_VAR:                for dp in range(depth):                    col_names = []                    col_values = []                                        col_names.extend([VARS["depth_true_" + str(d) + "_" + str(dp)] for d in range(data_size)])                    col_values.extend([1 for d in range(data_size)])                    row_names.append("#" + str(row_value))                    row_values.append([col_names,col_values])                    row_right_sides.append(0.5 * data_size)                    row_senses = row_senses + "L"                    row_value = row_value + 1                        else:                for n in range(num_nodes):                    lower_leafs = get_left_leafs(n, num_nodes)                    col_names = []                    col_values = []                                        for l in lower_leafs:                        col_names.extend([VARS["leaf_" + str(d) + "_" + str(l)] for d in range(data_size)])                        col_values.extend([1 for d in range(data_size)])                    row_names.append("#" + str(row_value))                    row_values.append([col_names,col_values])                    row_right_sides.append(0.5 * data_size)                    row_senses = row_senses + "L"                    row_value = row_value + 1    return row_names, row_values, row_right_sides, row_senses    if inputsym == 1:        if double_data == True:            for dp in range(1,depth+1):                left_leafs = []                for n in range(num_nodes):                    if get_depth(n, num_nodes) == dp:                        left_leafs.extend(get_left_leafs(n, num_nodes))                        right_leafs = []                for n in range(num_nodes):                    if get_depth(n, num_nodes) == dp:                        right_leafs.extend(get_right_leafs(n, num_nodes))                col_names = []                col_values = []                col_names.extend([VARS["prediction_" + str(l)] for l in left_leafs])                col_values.extend([1 for l in left_leafs])                col_names.extend([VARS["prediction_" + str(r)] for r in right_leafs])                col_values.extend([-1 for r in right_leafs])                row_names.append("#" + str(row_value))                row_values.append([col_names,col_values])                row_right_sides.append(0)                row_senses = row_senses + "L"                row_value = row_value + 1    return row_names, row_values, row_right_sides, row_sensesdef print_nodes(node, diff, depth, solution_values, num_nodes, num_features):    if diff > 0:        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), "<", solution_values[VARS["node_constant_max_" + str(node) + "_" + str(f)]]        print_nodes(node-diff, diff/2, depth+1, solution_values, num_nodes, num_features)        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), ">", solution_values[VARS["node_constant_min_" + str(node) + "_" + str(f)]]        print_nodes(node+diff, diff/2, depth+1, solution_values, num_nodes, num_features)    else:        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), "<", solution_values[VARS["node_constant_max_" + str(node) + "_" + str(f)]]        for l in get_left_leafs(node, num_nodes):            print "  " * (depth+1), l, solution_values[VARS["prediction_" + str(l)]]        for f in range(num_features):            if solution_values[VARS["node_feature_" + str(node) + "_" + str(f)]] > 0.5:                print "  " * depth, node, get_feature(f), ">", solution_values[VARS["node_constant_min_" + str(node) + "_" + str(f)]]        for l in get_right_leafs(node, num_nodes):            print "  " * (depth+1), l, solution_values[VARS["prediction_" + str(l)]]def print_tree(num_nodes, solution_values, num_features):    print "tree:"    diff = (num_nodes + 1) / 2    print_nodes(diff-1, diff / 2, 0, solution_values, num_nodes, num_features)def get_start_solutions(depth):    col_var_names = []    col_var_values = []    num_features = get_num_features()    num_leafs = 2**depth    num_nodes = num_leafs-1    for n in range(num_nodes):        if sget_feature(tr.dt, convert_node(tr.dt, n, num_nodes)) >= 0:            for f in range(num_features):                if f == sget_feature(tr.dt, convert_node(tr.dt, n, num_nodes)):                    col_var_names.extend([VARS["node_feature_" + str(n) + "_" + str(f)]])                    col_var_values.extend([1])                else:                    col_var_names.extend([VARS["node_feature_" + str(n) + "_" + str(f)]])                    col_var_values.extend([0])    for n in range(num_nodes):        if sget_node_constant(tr.dt, convert_node(tr.dt, n, num_nodes)) >= 0.0:            col_var_names.extend([VARS["node_constant_" + str(n)]])            col_var_values.extend([int(sget_node_constant(tr.dt, convert_node(tr.dt, n, num_nodes)))])        else:            col_var_names.extend([VARS["node_constant_" + str(n)]])            col_var_values.extend([int(-1.0 + sget_node_constant(tr.dt, convert_node(tr.dt, n, num_nodes)))])    return col_var_names, col_var_values    def lpdtree(depth):    global SORTED_FEATURE, inputstart, inputtime, inputpolish    prob = cplex.Cplex()    num_features = get_num_features()    data_size = get_data_size()    num_leafs = 2**depth    num_nodes = num_leafs-1    try:        prob.objective.set_sense(prob.objective.sense.minimize)        var_names, var_types, var_lb, var_ub, var_obj = create_variables(depth)        print "num_vars", len(var_names)        prob.variables.add(obj = var_obj, lb = var_lb, ub = var_ub, types = var_types)        row_names, row_values, row_right_sides, row_senses = create_rows(depth)        print "num_rows", len(row_names)        prob.linear_constraints.add(lin_expr = row_values, senses = row_senses, rhs = row_right_sides, names = row_names)                #row_names, row_values, row_right_sides, row_senses, row_value = create_min_max_leaf_rows(depth, len(row_names))                #print "num_rows", len(row_names)           #prob.linear_constraints.advanced.add_lazy_cuts(lin_expr = row_values, senses = row_senses, rhs = row_right_sides, names = row_names)                col_names = []        order_set = []        for n in range(num_nodes):            for f in range(num_features):                order_set.append((VARS["node_feature_" + str(n) + "_" + str(f)], 11+2*((num_nodes - get_num_parents(n,num_nodes))), 1))        for n in range(num_nodes):            order_set.append((VARS["node_constant_" + str(n)], 10+2*((num_nodes - get_num_parents(n,num_nodes))), -1))        if ctype == DEPTH_VAR or ctype == LEAFDEPTH_VAR or ctype == SCORE_VAR or ctype == UPDOWNDERR_VAR:            for l in range(depth):                for d in range(data_size):                    order_set.append((VARS["depth_true_" + str(d) + "_" + str(l)], 1 +(depth - l), -1))               prob.order.set(order_set)        if inputstart == 1:            col_var_names, col_var_values = get_start_solutions(depth)            prob.MIP_starts.add([col_var_names, col_var_values], prob.MIP_starts.effort_level.auto)            prob.write("test.lp")        prob.parameters.emphasis.mip.set(1)        #prob.parameters.advance.set(2)        #prob.parameters.mip.strategy.branch.set(1)        #prob.parameters.mip.strategy.backtrack.set(1.0)        #prob.parameters.mip.strategy.nodeselect.set(2)        prob.parameters.mip.strategy.variableselect.set(-1)        #prob.parameters.mip.strategy.bbinterval.set(0)        #prob.parameters.mip.strategy.rinsheur.set(50)        #prob.parameters.mip.strategy.lbheur.set(1)        #prob.parameters.mip.strategy.probe.set(3)        #prob.parameters.preprocessing.presolve.set(1)        prob.parameters.mip.polishafter.time.set(inputtime - inputpolish)        prob.parameters.timelimit.set(inputtime)                        prob.solve()    except CplexError, exc:        print exc        return        print    print "Solution status = " , prob.solution.get_status(), ":", prob.solution.status[prob.solution.get_status()]    if "infeasible" in prob.solution.status[prob.solution.get_status()]:        return []        print "Solution value  = ", prob.solution.get_objective_value()        num_features = get_num_features()    data_size = get_data_size()        num_leafs = 2**depth    num_nodes = num_leafs-1    solution = []    solution_values = prob.solution.get_values()        print_tree(num_nodes, solution_values, num_features)        return solutiondef run():    read_file('winequality-red.csv')    #read_file('iris.csv')    transform_data()    write_file('winequality-red-transformed.csv')    tr.df = tr.get_wine_data()    tr.learnTrees(3)    tr.get_code()    lpdtree(3)import sys, getoptdef main(argv):   global inputstart   global inputsym   global inputtime   global inputpolish   global double_data   global ctype   global continuousconstant   inputfile = ''   outputfile = 'out'   try:      opts, args = getopt.getopt(argv,"f:d:s:y:t:p:u:v:c:",["ifile=","depth=","start=","symmetry=","timelimit=","polishtime=","doubledata=","variant=","constant="])   except getopt.GetoptError:      sys.exit(2)   for opt, arg in opts:      if opt in ("-f", "--ifile"):         inputfile = arg      elif opt in ("-d", "--depth"):         inputdepth = int(arg)      elif opt in ("-s", "--start"):         inputstart = int(arg)      elif opt in ("-y", "--symmetry"):         inputsym = int(arg)      elif opt in ("-u", "--doubledata"):         if int(arg) == 1:            double_data = True            set_double_data(True)         else:            double_data = False            set_double_data(False)      elif opt in ("-t", "--timelimit"):         inputtime = int(arg)      elif opt in ("-p", "--polishtime"):         inputpolish = int(arg)      elif opt in ("-v", "--variant"):         ctype = int(arg)      elif opt in ("-c", "--constant"):         continuousconstant = int(arg)   read_file(inputfile)   #read_file('iris.csv')   transform_data()   write_file(inputfile+".transformed")   tr.df = tr.get_data(inputfile+".transformed")   tr.learnRegTrees(inputdepth)   tr.get_code()   lpdtree(inputdepth)"""if __name__ == "__main__":   main(sys.argv[1:])"""main(["-fIndiansDiabetes.csv","-d 3","-t 30","-y 1","-p 1","-c 1","-v 5"])