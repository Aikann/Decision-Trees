import cplexfrom cplex.exceptions import CplexErrorimport sysimport csvfrom scipy.stats.stats import pearsonrimport regtrees as trimport math#inputstart = 0#inputsym = 0#inputtime = 900#inputpolish = 100#double_data = True# The data, DATA_TABLE[-1] contains the target, others are featuresDATA_TABLE = []# The weights for each data point, corresponding to the dataWEIGHTS_TABLE = []# MIN and MAX values for every feature, feature is an intMIN_VALUE = dict()MAX_VALUE = dict()# MIN and MAX targetsTARGETS = []# MINIMUM DISTANCE between feature valuesMIN_DIST = 1.0# USED BY input readingMAX_VALUES = []# VARIABLE NAMES FOR LP ENCODINGVARS = dict()double_data = Falsedef set_double_data(setting):    global double_data    double_data = setting# OLD code from tree encoding, imported in order to use trees as starting solutions# all functions starting with s get values from scikitlearn tree objectsdef sget_feature(tree, index):    return tree.tree_.feature[index]def sget_leaf_constant(tree, index):    return tree.tree_.value[index]def sget_node_constant(tree, index):    return tree.tree_.threshold[index]def sget_left_node(tree, index):    return tree.tree_.children_left[index]def sget_right_node(tree, index):    return tree.tree_.children_right[index]def sget_parent_node(tree, index):    if index == 0:        return -1    for i in range(len(tree.tree_.children_left)):        if tree.tree_.children_left[i] == index:            return i    for i in range(len(tree.tree_.children_right)):        if tree.tree_.children_right[i] == index:            return index    return -1def sget_path(tree, index):    if index == 0:        return [], []    for i in range(len(tree.tree_.children_left)):        if tree.tree_.children_left[i] == index:            path, truth_values = get_path(tree,i)            path.append(str(i))            truth_values.append(0)            return path, truth_values    for i in range(len(tree.tree_.children_right)):        if tree.tree_.children_right[i] == index:            path, truth_values = get_path(tree,i)            path.append(str(i))            truth_values.append(1)            return path, truth_values    return [], []def sget_parent(tree, index):    if index == 0:        return ""    for i in range(len(tree.tree_.children_left)):        if tree.tree_.children_left[i] == index:            return str(i) + "_T"    for i in range(len(tree.tree_.children_right)):        if tree.tree_.children_right[i] == index:            return str(i) + "_F"    return ""def sget_children(tree, index):    return tree.tree_.children_left[index], tree.tree_.children_right[index]def sget_lower_leafs(tree, index):    result = []    left, right = sget_children(tree, index)    if left != -1:        result = result + sget_lower_leafs(tree, left)        result = result + sget_lower_leafs(tree, right)    else:        return [index]    return result    def sget_left_leafs(tree, index):    left, right = sget_children(tree, index)    if left != -1:        return sget_lower_leafs(tree, left)    return []def sget_right_leafs(tree, index):    left, right = sget_children(tree, index)    if right != -1:        return sget_lower_leafs(tree, right)    return []def sget_bounds(tree, index):    left, right = get_children(tree, index)    leftub,leftlb,rightub,rightlb = 0.0,0.0,0.0,0.0    if tree.tree_.children_left[left] != -1:        leftlb,leftub = get_bounds(tree, left)    else:        leftlb,leftub = get_leaf_constant(tree,left),get_leaf_constant(tree,left)            if tree.tree_.children_right[left] != -1:        rightlb,rightub = get_bounds(tree, right)    else:        rightlb,rightub = get_leaf_constant(tree,right),get_leaf_constant(tree,right)    return min(leftlb, rightlb), max(leftub,rightub)def snode_lists(trees):    leafs = dict()    nodes = dict()    for t in gen._ITEMS_:        ls = []        ns = []        for i in range(len(trees[t].tree_.value)):            if trees[t].tree_.children_left[i] != -1:                ns.append(i)            else:                ls.append(i)        leafs[t] = ls        nodes[t] = ns    return nodes, leafs# functions for tree traversing and getting min/max/row values for features and the target# get min values for feature fdef get_min_value_f(f):    global MIN_VALUE    if double_data == False:        return MIN_VALUE[f]    if f >= len(DATA_TABLE[0]) - 1:        f = f-len(DATA_TABLE[0]) + 1        return get_max_value() - MAX_VALUE[f]    return MIN_VALUE[f]# get min value over all featuresdef get_min_value():    global MIN_VALUE    return min(MIN_VALUE.itervalues())# get max value for feature fdef get_max_value_f(f):    global MAX_VALUE        if double_data == False:        return MAX_VALUE[f]        if f >= len(DATA_TABLE[0]) - 1:        f = f-len(DATA_TABLE[0]) + 1        return get_max_value() - MIN_VALUE[f]    return MAX_VALUE[f]# get max value over all featuresdef get_max_value():    global MAX_VALUE    return max(MAX_VALUE.itervalues())def get_max_target():    return max(TARGETS)def get_min_target():    return min(TARGETS)def get_max_error():    return get_max_target() - get_min_target()# get feature value f in row ddef get_feature_value(d,f):    if double_data == False:        return DATA_TABLE[d+1][f]        if f < len(DATA_TABLE[0]) - 1:        return DATA_TABLE[d+1][f]    return get_max_value() - DATA_TABLE[d+1][f-len(DATA_TABLE[0])+1]# get target in row ddef get_target(d):    return DATA_TABLE[d+1][-1]# get weight in row ddef get_weight(d):    return WEIGHTS_TABLE[d+1]    # get size of input tabledef get_data_size():    return len(DATA_TABLE) - 1# get number of featuresdef get_num_features():    if double_data == False:        return len(DATA_TABLE[0]) - 1        return 2*(len(DATA_TABLE[0]) - 1)# get number of targetsdef get_num_targets():    return len(TARGETS)# get feature name for feature fdef get_feature(f):    if double_data == False:        return DATA_TABLE[0][f]        if f < len(DATA_TABLE[0]) - 1:        return DATA_TABLE[0][f]    return "inv" + DATA_TABLE[0][f-len(DATA_TABLE[0]) + 1]# get d'th feature value, sorted by increasing value, used to sorting functionSORTED_FEATURE = 0def get_sorted_feature_value(d):    global SORTED_FEATURE    return get_feature_value(d, SORTED_FEATURE)# get all unique targets, sorted by increasing valuedef get_sorted_targets():    return list(sorted(set([DATA_TABLE[d+1][-1] for d in range(get_data_size())])))# get all unique feature values for feature f, sorted by increasing valuedef get_sorted_feature_values(f):    if double_data == False:        return list(sorted(set([DATA_TABLE[d+1][f] for d in range(get_data_size())])))        if f < len(DATA_TABLE[0]) - 1:        return list(sorted(set([DATA_TABLE[d+1][f] for d in range(get_data_size())])))    return list(sorted(set([get_max_value() - DATA_TABLE[d+1][f - len(DATA_TABLE[0]) + 1] for d in range(get_data_size())])))# read data, set min max values, put into DATA_TABLEdef read_file(file_name):    global DATA_TABLE, MIN_VALUE, MAX_VALUE, MIN_TARGET, MAX_TARGET    data = []    header = True    with open(file_name, 'rb') as csvfile:        reader = csv.reader(csvfile, delimiter=';')        for row in reader:            if header is False:                row = [float(i) for i in row]                if row[-1] not in TARGETS:                    TARGETS.append(row[-1])                for f in range(len(row) - 1):                    if f not in MIN_VALUE or MIN_VALUE[f] > row[f]:                        MIN_VALUE[f] = row[f]                    if f not in MAX_VALUE or MAX_VALUE[f] < row[f]:                        MAX_VALUE[f] = row[f]            header = False            data.append(row)        DATA_TABLE = data# read weights in the first column, put into WEIGHTS_TABLEdef read_weights(file_name):    global WEIGHTS_TABLE    weights = []    header = True    with open(file_name, 'rb') as csvfile:        reader = csv.reader(csvfile, delimiter=';')        for row in reader:            if header is False:                row = [float(i) for i in row]            header = False            weights.append(row[0])        WEIGHTS_TABLE = weights# write datadef write_file(file_name):    global DATA_TABLE, MIN_VALUE, MAX_VALUE, MIN_TARGET, MAX_TARGET    data = []    header = True    with open(file_name, 'wb') as csvfile:        writer = csv.writer(csvfile, delimiter=';', quoting=csv.QUOTE_NONE)        for d in range(len(DATA_TABLE)):            writer.writerow(DATA_TABLE[d])# transform data to successive integers, centered around 0def transform_data():    global MIN_VALUE, MAX_VALUE, DATA_TABLE, MAX_VALUES, CORRS, MIN_DIST, SORTED_FEATURE    CORRS = dict()    targets = []    for d in range(1,len(DATA_TABLE)):        targets.append(DATA_TABLE[d][-1])        # scale to 0.0-1.0, not needed##    for index in range(len(DATA_TABLE[0])-1):##        for d in range(1,len(DATA_TABLE)):##            DATA_TABLE[d][index] = float(DATA_TABLE[d][index] - get_min_value_f(index)) / float(get_max_value_f(index) - get_min_value_f(index))    # assign integers from 1 to the number of unique values    MIN_DIST = 1.0    for index in range(len(DATA_TABLE[0])-1):        MAX_VALUE[index] = 1.0        MIN_VALUE[index] = 0.0        values = []        for d in range(1,len(DATA_TABLE)):            values.append(DATA_TABLE[d][index])        values = sorted(set(values))        for d in range(1,len(values)-1):            if MIN_DIST > (values[d+1] - values[d]):                MIN_DIST = (values[d+1] - values[d])        for d in range(1,len(DATA_TABLE)):            for v in range(len(values)):                if values[v] == DATA_TABLE[d][index]:                    DATA_TABLE[d][index] = float(v)                    break        MAX_VALUE[index] = len(values) - 1.0        MAX_VALUES.append(len(values) - 1.0)        MIN_VALUE[index] = 0.0    MIN_DIST = 1.0        MAX_VALUES = []    # checks if successive occurrences of a feature-value have the same target-value    # if all occurrences of two successive values have the same target, they are combined    for index in range(len(DATA_TABLE[0])-1):        SORTED_FEATURE = index        all_rows = sorted(range(len(DATA_TABLE)-1), key=get_sorted_feature_value)                cut_points = [0.0]        previous_target = -1000        for d in all_rows:            if previous_target != get_target(d):                cut_points.extend([get_feature_value(d,index)])            previous_target = get_target(d)        cut_points.extend([len(DATA_TABLE)])        cut_points = list(sorted(set(cut_points)))        previous_cut_point = -1000        data_copy = [DATA_TABLE[d][index] for d in range(len(DATA_TABLE))]        for v in range(len(cut_points)):            for d in range(1,len(DATA_TABLE)):                if cut_points[v] >= data_copy[d] and previous_cut_point < data_copy[d]:                    DATA_TABLE[d][index] = float(v)            previous_cut_point = cut_points[v]        MAX_VALUE[index] = len(cut_points)        MAX_VALUES.append(len(cut_points))        MIN_VALUE[index] = 0.0        # translate all feature value to be centered around 0    for d in range(1,len(DATA_TABLE)):        for index in range(len(DATA_TABLE[0])-1):            maxv = MAX_VALUE[index]            DATA_TABLE[d][index] = DATA_TABLE[d][index] - int(float(maxv)/2.0) + 1.0    for index in range(len(DATA_TABLE[0])-1):        maxv = MAX_VALUE[index]        MIN_VALUE[index] = MIN_VALUE[index] - int(float(maxv)/2.0) + 1.0        MAX_VALUE[index] = MAX_VALUE[index] - int(float(maxv)/2.0) + 1.0    return# Getting tree structural values (parents, children, etc), num_nodes is the total number of nodes in the tree## Example numbering for a tree of depth 3, leafs are numbered seperately:##         3            nodes#     1       5#   0   2   4   6#  0 1 2 3 4 5 6 7     leafs### recursive, get total number of leafs under nodedef get_num_leafs(node, num_nodes):    check = num_nodes / 2    if node > check:        return get_num_leafs(node - check, check)    if node < check:        return get_num_leafs(node, check)    return check# get right leafs under nodedef get_right_leafs(node, num_nodes):    num_leafs = get_num_leafs(node+1, num_nodes+1)    return range(node+1, node+1 + num_leafs)# get left leafs under nodedef get_left_leafs(node, num_nodes):    num_leafs = get_num_leafs(node+1, num_nodes+1)    return range(node+1 - num_leafs, node+1)# get left nodes (not leafs) under nodedef get_left_nodes(node, num_nodes):    return get_left_leafs(node, num_nodes)[0:-1]# get right nodes (not leafs) under nodedef get_right_nodes(node, num_nodes):    return get_right_leafs(node, num_nodes)[0:-1]def get_depth(node, num_nodes):    #print node, num_nodes    if node < (num_nodes-1)/2:        return 1 + get_depth(node, ((num_nodes+1)/2) - 1)    if node > (num_nodes-1)/2:        return 1 + get_depth(node - ((num_nodes+1)/2), ((num_nodes+1)/2) - 1)    return 1def get_left_node(node, num_nodes):    max_depth = int(math.log(num_nodes + 1, 2)) - 1    if node % 2 == 0: return -1    return node - (2 ** (max_depth - get_depth(node, num_nodes)))def get_right_node(node, num_nodes):    max_depth = int(math.log(num_nodes + 1, 2)) - 1    if node % 2 == 0: return -1    return node + (2 ** (max_depth - get_depth(node, num_nodes)))# recursive, get path from node to root nodedef get_path_recur(node, leaf, diff):    if diff < 1:        if leaf <= node:            return [node, "left"]        return [node, "right"]    if leaf <= node:        return get_path_recur(node - diff, leaf, diff / 2) + [node, "left"]    return get_path_recur(node + diff, leaf, diff / 2) + [node, "right"]# get path from leaf to root nodedef get_path(leaf, num_nodes):    return get_path_recur(((num_nodes+1) / 2) - 1, leaf, ((num_nodes+1) / 2) / 2)# get path from node to root node, including nodedef get_pathn(node, num_nodes):    leaf = min(get_right_leafs(node, num_nodes))    path = get_path(leaf, num_nodes)    path_len = int(len(path)/2.0)        for i in range(path_len):        n = path[i*2]        if n == node:            return path[i*2:len(path)]    return []def convert_node(tree, node, num_nodes):    path = get_pathn(node, num_nodes)    path_len = int(len(path)/2.0)        index = 0        for l in reversed(range(1,path_len)):        node = path[l*2]        dir = path[l*2+1]                        if sget_right_node(tree, index) == -1:            return index        if dir == "left":            index = sget_right_node(tree, index)        if dir == "right":            index = sget_left_node(tree, index)    return indexdef convert_leaf(tree, leaf, num_nodes):    path = get_path(leaf, num_nodes)    path_len = int(len(path)/2.0)        index = 0        for l in reversed(range(path_len)):        node = path[l*2]        dir = path[l*2+1]                if sget_right_node(tree, index) == -1:            return index                if dir == "left":            index = sget_right_node(tree, index)        if dir == "right":            index = sget_left_node(tree, index)    return index# recursive, used to get number of parents of node until rootdef get_num_parents_recur(node, target, diff):    if diff < 1:        return 0    if target == node:        return 0    if target > node:        return get_num_parents_recur(node + diff, target, diff / 2) + 1    return get_num_parents_recur(node - diff, target, diff / 2) + 1# get number of parents of node until rootdef get_num_parents(node, num_nodes):    return get_num_parents_recur(((num_nodes+1) / 2) - 1, node, ((num_nodes+1) / 2) / 2)def get_parent(node, depth):        num_nodes = 2**depth -1        actual_depth = get_depth(node, num_nodes)        internal_nodes_above = depth - actual_depth        parent1 = node + 2**internal_nodes_above        parent2 = node - 2**internal_nodes_above        if parent1<num_nodes-1 and get_left_node(parent1, num_nodes) == node:                return parent1        else:                return parent2